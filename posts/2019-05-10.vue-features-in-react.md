---
title: Vue features in React
tags:
    - javascript
    - react
    - vue
---

...

<!-- more -->

## Templates

...

```html
<!-- Greeter.vue -->

<template>
  <p>Hello, {{ name }}!</p>
</template>

<script>
export default {
  props: ['name']
}
</script>
```

```js
export default function Greeter({ name }) {
  return <p>Hello, name!</p>;
}
```

### Conditional rendering

React alternative: Logical `&&` operator ternary statements, or early returns.

```html
<!-- Awesome.vue -->

<template>
  <article>
    <h1 v-if="awesome">Vue is awesome!</h1>
  </article>
</template>

<script>
export default {
  props: ['awesome']
}
</script>
```

```js
export default function Awesome({ awesome }) {
  return (
    <article>
      {awesome && <h1>React is awesome!</h1>};
    </article>
  );
}
```

```js
export default function Awesome({ awesome }) {
  if (!awesome) {
    return (
      <article>
        <h1>Oh no ðŸ˜¢</h1>
      </article>
    );
  }

  return (
    <article>
      <h1>React is awesome!</h1>
    </article>
  );
}
```

```js
export default function Awesome({ awesome }) {
  return (
    <article>
      {awesome ? (
        <h1>React is awesome!</h1>
      ) : (
        <h1>Oh no ðŸ˜¢</h1>
      )};
    </article>
}
```

### List rendering

React alternative: `Array.map`.

```html
<!-- Recipe.vue -->

<template>
  <ul>
    <li v-for="(ingredient, index) in ingredients" :key="index">
      {{ ingredient }}
    </li>
  </ul>
</template>

<script>
export default {
  props: ['ingredients']
}
</script>
```

```js
export default function Recipe({ ingredients }) {
  return (
    <ul>
      {ingredients.map((ingredient, index) => (
        <li key={index}>{ingredient}</li>
      ))}
    </ul>
  );
}
```

### Class and style bindings

React alternative: Manually pass props.

```html
<!-- Post.vue -->

<template>
  <article>
    <h1>{{ title }}</h1>
  </article>
</template>

<script>
export default {
  props: ['title'],
}
</script>

<!--
<post
  :title="About CSS"
  class="margin-bottom"
  style="color: red"
/>
-->
```

```js
export default function Post({ title, className, style }) {
  return (
    <article className={className} style={style}>
      {title}
    </article>
  );
}

// <Post
//   title="About CSS"
//   className="margin-bottom"
//   style={{ color: 'red' }}
// />
```

```js
export default function Post({ title, ...props }) {
  return (
    <article {...props}>
      {title}
    </article>
  );
}
```

## Props

React alternative: Props.

```html
<!-- Post.vue -->

<template>
  <h1>{{ title }}</h1>
</template>

<script>
export default {
  props: ['title'],
}
</script>
```

```js
export default function Post({ title }) {
  return <h3>{title}</h3>;
}
```

## Data / state

React alternative: The `useState` hook.

```html
<!-- ButtonCounter.vue -->

<template>
  <button @click="count++">
    You clicked me {{ count }} times.
  </button>
</template>

<script>
export default {
  data() {
    return {
      count: 0
    }
  }
}
</script>
```

```js
import { useState } from "react";

export default function ButtonCounter() {
  const [count, setCount] = useState(0);

  return (
    <button onClick={() => setCount(count + 1)}>
      {count}
    </button>
  );
}
```

### `v-model`

No syntactic sugar.

```html
<!-- Profile.vue -->

<template>
  <input type="text" v-model="name" />
</template>

<script>
export default {
  data() {
    return {
      name: 'Sebastian'
    }
  }
}
</script>
```

```js
import { useState } from "react";

export default function Profile() {
  const [name, setName] = useState('Sebastian');

  return (
    <input
      type="text"
      value={name}
      onChange={event => setName(event.target.name)}
    />
  );
}
```

## Computed properties

React alternative: Variables, optionally wrapped in `useMemo`.

```html
<!-- ReversedMessage.vue -->

<template>
  <p>{{ reversedMessage }}</p>
</template>

<script>
export default {
  props: ['message'],

  computed: {
    reversedMessage() {
      return this.message.split('').reverse().join('');
    }
  }
}
</script>
```

```js
export default function ReversedMessage({ message }) {
  const reversedMessage = message.split('').reverse().join('');

  return <p>{reversedMessage}</p>;
}
```

If performance is a concern, the computation can be wrapped in `useMemo`.

```js
export default function ReversedMessage({ message }) {
  const reversedMessage = useMemo(() => {
    return message.split('').reverse().join('');
  }, [message]);

  return <p>{reversedMessage}</p>;
}
```

## Methods

React alternative: Functions.

```html
<!-- ImportantButton.vue -->

<template>
  <button onClick="doSomething">Do something!</button>
</template>

<script>
export default {
  methods: {
    doSomething() {
      // ...
    }
  }
}
</script>
```

```js
export default function ImportantButton() {
  function doSomething() {
    // ...
  }

  return (
    <button onClick={doSomething}>
      Do something!
    </button>
  );
}
```

## Events

React alternative: Props containing callbacks.

```html
<!-- PostForm.vue -->

<template>
  <form>
    <button type="button" @click="$emit('save')">Save</button>
    <button type="button" @click="$emit('publish')">Publish</button>
  </form>
</template>
```

```js
export default function PostForm({ onSave, onPublish }) {
  return (
    <form>
      <button type="button" onClick={onSave}>Save</button>
      <button type="button" onClick={onPublish}>Publish</button>
    </form>
  );
}
```

### Event modifiers

React alternative: Higher order functions.

```html
<!-- AjaxForm.vue -->

<template>
  <form @submit.prevent="submitWithAjax">
    <!-- ... -->
  </form>
</template>

<script>
export default {
  methods: {
    submitWithAjax() {
      // ...
    }
  }
}
</script>
```

```js
export default function AjaxForm() {
  function submitWithAjax(event) {
    event.preventDefault();

    // ...
  }

  return (
    <form onSubmit={submitWithAjax}>
      {/* ... */}
    </form>
  );
}
```

```js
function prevent(callback) {
  return (event) => {
      event.preventDefault();

      callback(event);
  };
}

export default function AjaxForm() {
  function submitWithAjax(event) {
    // ...
  }

  return (
    <form onSubmit={prevent(submitWithAjax)}>
      {/* ... */}
    </form>
  );
}
```

## Lifecycle methods

React alternative: The `useEffect` hook.

```html
<template>
  <div />
</template>

<script>
export default {
  mounted() {
   console.log('Mounted!');
  },

  beforeDestroy() {
    console.log('Unmounting...');
  }
}
</script>
```

```js
import { useEffect} from 'react';

export default function Component() {
  useEffect(() => {
    console.log('Mounted!');

    return () => {
      console.log('Unmounting...');
    };
  }, []);

  return <div />;
}
```

## Watchers

React alternative: The `useEffect` hook.

```html
<!-- AjaxToggle.vue -->

<template>
  <input type="checkbox" v-model="checked" />
</template>

<script>
export default {
  data() {
    return {
      checked: false
    }
  },

  watch: {
    checked(checked) {
      syncWithServer(checked);
    }
  },

  methods: {
    syncWithServer(checked) {
      // ...
    }
  }
}
</script>
```

```js
import { useEffect, useState } from 'react';

export default function AjaxToggle() {
  const [checked, setChecked] = useState(false);

  function syncWithServer(checked) {
    // ...
  }

  useEffect(() => {
    syncWithServer(checked);
  }, [checked]);

  return (
    <input
      type="checkbox"
      checked={checked}
      onChange={() => setChecked(!checked)}
    />
  );
}
```

```js
import { useEffect, useRef, useState } from 'react';

export default function AjaxToggle() {
  const [checked, setChecked] = useState(false);
  const firstRender = useRef(true);

  function syncWithServer(checked) {
    // ...
  }

  useEffect(() => {
    if (firstRender.current) {
      firstRender.current = false;
      return;
    }

    syncWithServer(checked);
  }, [checked]);

  return (
    <input
      type="checkbox"
      checked={checked}
      onChange={() => setChecked(!checked)}
    />
  );
}
```

## Slots & scoped slots

React alternative: Props containing components or callbacks that return components.

```html
<!-- RedParagraph.vue -->

<template>
  <p style="color: red">
    <slot />
  </p>
</template>
```

```js
export default function RedParagraph({ children }) {
  return (
    <p style={{ color: 'red' }}>
      {children}
    </p>
  );
}
```

Named slots

```html
<!-- Layout.vue -->

<template>
  <div class="flex">
    <section class="w-1/3">
        <slot name="sidebar" />
    </section>
    <main class="flex-1">
        <slot />
    </main>
  </div>
</template>
```

```html
<layout>
  <template #sidebar>
    <nav>...</nav>
  </template>
  <template #default>
    <post>...</post>
  </template>
</layout>
```

```js
export default function RedParagraph({ sidebar, children }) {
  return (
    <div className="flex">
      <section className="w-1/3">
        {sidebar}
      </section>
      <main className="flex-1">
        {children}
      </main>
    </div>
  );
}
```

```js
<Layout sidebar={<nav>...</nav>}>
  <Post>...</Post>
</Layout>
```

Scoped slots

```html
<!-- CurrentUser.vue -->

<template>
  <span>
    <slot :user="user" />
  </span>
</template>

<script>
export default {
  inject: ['user']
}
</script>
```

```html
<template>
  <current-user>
    <template #default="{ user }">
      {{ user.firstName }}
    </template>
  </current-user>
</template>
```

```js
import { useContext } from 'react';
import UserContext from './UserContext';

export default function CurrentUser({ children }) {
  const { user } = useContext(UserContext);

  return (
    <span>
      {children(user)}
    </span>
  );
}
```

```js
<CurrentUser>
  {user => user.firstName}
</CurrentUser>
```

## Provide / inject / context

React alternative: `createContext` and the `useContext` hook.

```html
<!-- MyProvider.vue -->

<template>
  <div><slot /></div>
</template>

<script>
export default {
  provide: {
    foo: 'bar'
  },
}
</script>
```

```html
<!-- MyConsumer.vue -->
<!-- Must be rendered inside a MyProvider instance -->

<template>
  <p>{{ foo }}</p>
</template>

<script>
export default {
  inject: ['foo']
}
</script>
```

```js
import { createContext, useContext } from 'react';

const fooContext = createContext('foo');

function MyProvider({ children }) {
  return (
    <FooContext.Provider value="foo">
      {children}
    </FooContext.Provider>
  );
}

// Must be rendered inside a MyProvider instance
function MyConsumer() {
  const foo = useContext(FooContext);

  return <p>{foo}</p>;
}
```

## Transitions

React alternative: Third party libraries.
